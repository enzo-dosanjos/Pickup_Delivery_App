@startuml MCD

package "Persistence" {
    class XMLParsers {
        + parseMap(filePath: string) : Map
        + parseRequests(filePath: string, pickupDeliveryToFill: PickupDelivery) : void
        + parseTours(filePath: string) : Tour
    }

    class XMLWriters {
        + writeTour(tour: Tour, filePath: string) : void
        + writeRequests(requests: PickupDelivery, filePath: string) : void
        + writeMap(map: Map, filePath: string) : void
    }
}

package "Domain" {
    package "model" {
        class Intersection {
            - id : long
            - lat : double
            - lng : double
        }

        class RoadSegment {
            - name : string
            - length : double
            - startId : long
            - endId : long
        }

        class Map {
            - intersections : TreeMap<long, Intersection>  (key: intersection id)
            - adjencyList : HashMap<long, RoadSegment[]>  (key: starting intersection id)
            + addIntersection(intersection: Intersection) : boolean
            + addRoadSegment(intersectionId: Long, roadSegment: RoadSegment) : boolean
            + getRoadSegment(startId: long, endId: long) : RoadSegment
        }

        class Tour {
            - courierId : long
            - stops : TourStop[]
            - roadSegmentsTaken : RoadSegment[]
            - totalDistance : double
            - totalDuration : time.Duration
            + addStop(stop: TourStop) : void
            + updateTotalDistance(stop: TourStop) : void
            + updateTotalDuration(stop: TourStop) : void
        }

        class TourStop {
            - type : StopType
            - requestId : long
            - intersectionId : long
            - arrivalTime : LocalDateTime
            - departureTime : LocalDateTime
        }

        enum StopType {
            - Pickup
            - Delivery
            - IntermediateIntersection
            - Warehouse
        }

        class Request {
            - id : long
            - warehouseId : long
            - pickupIntersectionId : long
            - pickupDuration : time.Duration
            - deliveryIntersectionId : long
            - deliveryDuration : time.Duration
        }

        class Courier {
            - id : long
            - name : string
            - numGivenRequests : int
            - shiftDuration : time.Duration
        }

        class PickupDelivery {
            - requests : TreeMap<long, Request>  (key: request id)
            - requestsPerCourier : TreeMap<long, long[]>  (key: courier id, value: list of request ids)
            + addRequest(courierId: long, request: Request) : void
            + getRequestsForCourier(courierId: long) : Request[]
        }

        class Graphe {
            + getNbSommets() : int
            + getCout(i: int, j: int): int
            + estArc(i: int, j: int): boolean
        }

        class GrapheComplet {
            - sommets : long[]
            - nbSommets : int
            - cout : int[][]
            + GrapheComplet(sommets: long[]) : void
            + GrapheComplet(nbSommets: int) : void
            + estArc(i: int, j: int): boolean
        }
    }

    package "service" {
        class MapService {
            - map : Map
            + loadMap(filePath: string) : Map
            + getIntersectionsPerName(name: string) : Intersection[]  (can give partial name)
        }

        class RequestService {
            - pickupDelivery : PickupDelivery
            + addRequest(warehouseId, pickupIntersectionId, pickupDuration, deliveryIntersectionId, deliveryDuration, courierId)
            + getRequestsForCourier(id) : Request[]
            + loadRequests(filepath: String) : void
            + saveRequests(filepath: String) : void
        }

        class DijkstraService {
            + compareTo(map: Map, startId: long, endId: long) : double
            + computeShortestPath(map: Map, requests: long[]) : pair<GrapheComplet, long[][]>  (pair of graph and matrix of predecessors)
            + dijkstra(map: Map, graph: GrapheComplet, startId: long) : void
        }

        class TourService {
            - couriers : long[] (list of courier ids)
            - numCouriers : int
            - graph : GrapheComplet
            - tours : TreeMap<long, Tour>  (key: courier id)
            - requestOrder : TreeMap<long, pair<Long, Long>[]  (key: courier id, value: pair of ids of stop that should be before the other)
            + computeAllTours() : void
            + computeTourForCourier(id) : Tour
            + saveTours(filepath: String) : void
            + computeDistance(startId, endId): double
            + computeDuration(startId, endId): time.Duration
            + assignRequestsToCouriers() : void
            + updateNumCouriers(numCouriers: int) : void
            + updateRequestOrder(requestBeforeId: long, requestAfterId: long, courierId: long) : void
        }

        class IteratorSeq {
            - candidats : int[]
            - nbCandidats : int
            + IteratorSeq(nonVus: Collection<int>, sommetCrt: int, g: Graphe) : void
            + hasNext() : boolean
            + next() : int
            + remove() : void
        }

        class TemplateTSP {
            - meilleureSolution : int[]
            - g : Graphe
            - coutMeilleureSolution : int
            - tpsLimite : int
            - tpsDebut : long
            + chercheSolution(tpsLimite: int, g: Graphe) : void
            + getSolution(i: int) : int
            + getCoutSolution() : int
            + bound(sommetCourant: int, nonVus: Collection<int>) : int
            + iterator(sommetCrt: int, nonVus: Collection<int>, g: Graphe) : Iterator<int>
            + branchAndBound(sommetCrt: int, nonVus: Collection<int>, vus: Collection<int>, coutVus: int) : void
        }

        class TSP {
            + chercheSolution(tspLimite: int, g: Graphe): void
            + getSolution(i: int) : int
            + getCoutSolution() : int
        }

        class TSP1 {
            + bound(sommetCourant: int, nonVus: Collection<int>) : int
            + iterator(sommetCrt: int, nonVus: Collection<int>, g: Graphe) : Iterator<int>
        }
    }

    package "utils" {
        class DurationUtil {
            - COURIER_SPEED_KMH : double
            + computeDuration(roadSegment: RoadSegment) : double
        }
    }
}


package "Presentation" {
    class Main {
        + main(args: String[]): void
    }

    class MapController {
        + loadMap(filepath: String)
        + saveMap(filepath: String)
    }

    class RequestController {
        + addRequest(courierId: String, pickupIntersectionId: String, deliveryIntersectionId: String)
        + loadRequests(filepath: String)
        + saveRequests(filepath: String)
    }

    class TourController {
        + saveTours(filepath: String)
        + loadTours(filepath: String)
        + updateNumCouriers(numCouriers: int)
        + updateRequestOrder(requestBeforeId: long, requestAfterId: long)
        + showRequestDetails(requestId: long, deliveryOrPickup: StopType)
    }
}

MapController --> MapService
RequestController --> RequestService
TourController --> TourService

TourService --> RequestService
TourService --> MapService

MapService --> XMLParsers
MapService --> XMLWriters
RequestService --> XMLParsers
RequestService --> XMLWriters
TourService --> XMLWriters

TourService --> TSP1

TemplateTSP <|.. TSP1
TSP <|-- TemplateTSP
Graphe <|-- GrapheComplet

Map "1" *-- "*" Intersection
Map "1" *-- "*" RoadSegment

PickupDelivery "1" o-- "*" Request
Tour "1" *-- "*" TourStop
@enduml