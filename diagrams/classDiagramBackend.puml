@startuml MCD

package "Persistence" {
    class XMLParsers {
        + parseMap(filePath: string) : Map
        + parseRequests(filePath: string, courierId: long, pickupDeliveryToFill: PickupDelivery) : void
        + parseTours(filePath: string) : Tour
    }

    class XMLWriters {
        + writeTour(tour: Tour, filePath: string) : void
        + writeRequests(requests: PickupDelivery, filePath: string) : void
    }
}

package "Domain" {
    package "model" {
        class Intersection {
            - id : long
            - lat : double
            - lng : double
        }

        class RoadSegment {
            - name : string
            - length : double
            - startId : long
            - endId : long
        }

        class Map {
            - intersections : TreeMap<long, Intersection>  (key: intersection id)
            - adjencyList : HashMap<long, RoadSegment[]>  (key: starting intersection id)
            + addIntersection(intersection: Intersection) : boolean
            + addRoadSegment(startIntersectionId: Long, roadSegment: RoadSegment) : boolean
            + getRoadSegment(startId: long, endId: long) : RoadSegment
            + getRoadSegmentByName(name: string) : ArrayList<RoadSegment>  (can give partial name)
        }

        class Tour {
            - courierId : long
            - stops : ArrayList<TourStop>
            - roadSegmentsTaken : ArrayList<RoadSegment>
            - totalDistance : double
            - startTime : LocalDateTime
            - totalDuration : time.Duration
            + addStop(stop: TourStop) : void
            + addRoadSegment(roadSegment: RoadSegment) : void
            + updateTotalDistance(distance: double) : void
            + updateTotalDuration(duration: Duration) : void
            + getStopByIntersectionId(intersectionId: long) : TourStop
        }

        class TourStop {
            - type : StopType
            - requestId : long
            - intersectionId : long
            - arrivalTime : LocalDateTime
            - departureTime : LocalDateTime
        }

        enum StopType {
            - PICKUP
            - DELIVERY
            - INTERMEDIATE
            - WAREHOUSE
        }

        class Request {
            - id : long
            - warehouseId : long
            - pickupIntersectionId : long
            - pickupDuration : time.Duration
            - deliveryIntersectionId : long
            - deliveryDuration : time.Duration
            + generateId() : long
        }

        class Courier {
            - id : long
            - name : string
            - shiftDuration : time.Duration
            - availabilityStatus : AvailabilityStatus
            + isAvailable() : boolean
            + isBusy() : boolean
        }

        enum AvailabilityStatus {
            - AVAILABLE
            - BUSY
        }

        class PickupDelivery {
            - warehouseAdressId : long
            - requests : TreeMap<long, Request>  (key: request id)
            - requestsPerCourier : TreeMap<long, ArrayList<Long>>  (key: courier id, value: list of request ids)
            + getRequestsForCourier(courierId: long) : Request[]
            + addRequestToCourier(courierId: Long, request: Request) : boolean
            + removeRequestFromCourier(courierId: Long, requestId: long) : boolean
            + findRequestById(requestId: long) : Request
            + findRequestByIntersectionId(intersectionId: long) : Map.Entry<Request, StopType>
        }

        class Graphe {
            + getNbSommets() : int
            + getCout(i: int, j: int): int
            + estArc(i: int, j: int): boolean
        }

        class GrapheComplet {
            - sommets : long[]
            - nbSommets : int
            - cout : int[][]
            + GrapheComplet(sommets: long[]) : void
            + GrapheComplet(nbSommets: int) : void
            + estArc(i: int, j: int): boolean
        }

        package dijkstra {
            class Node {
                - vertex : Long
                - distance : double
                + Node(v: Long, d: double) : void
                + compareTo(other: Node) : int
            }

            class CellInfo {
                - distance : double
                - predecessor : long
                - visited : boolean
            }

            class DijkstraTable {
                - table : HashMap<Long, HashMap<Long, CellInfo>>  (key: startId, value: map of (key: endId, value: CellInfo))
                + put(row: lonf, col: long, distance: double, predecessor, visited: boolean) : void
                + put(row: long, col: long, cellInfo: CellInfo) : void
                + get(row: long, col: long) : CellInfo
                + contains(row: long, col: long) : boolean
                + remove(row: long, col: long) : void
            }
        }
    }

    package "service" {
        class DijkstraService {
            - map : Map
            - g : GrapheComplet
            + computeShortestPath(dijkstraTable: DijkstraTable) : void
            + dijkstra(start: int, dijkstraTable: DijkstraTable) : void
        }

        class RequestService {
            - pickupDelivery : PickupDelivery
            + addRequest(courierId: Long, request: Request) : void
            + deleteRequest(courierId: Long, requestId: long) : void
            + loadRequests(filepath: String) : void
            + saveRequests(filepath: String) : void
        }

        class TourService {
            - couriers : ArrayList<Courier> (list of courier ids)
            - numCouriers : int
            - tours : TreeMap<long, Tour>  (key: courier id)
            - requestOrder : TreeMap<Long, HashMap<Long, Long>>  (key: courier id, value: pair of ids of stop that should be before the other)
            + saveTours(filepath: String) : void
            + loadTours(filepath: String) : void
            + setTourForCourier(courierId: long, tour: Tour) : void
            + addCourier(courier: Courier) : boolean
            + removeCourier(courierId: long) : boolean
            + loadCouriers(filePath: string) : void
            + updateRequestOrder(requestBeforeId: long, requestAfterId: long, courierId: long) : void
            + convertGraphToTour(pickupDelivery: PickupDelivery, startTime: LocalDateTime, courierId: long, solution: Integer[], vertices: long[], costs: double[][]) : Tour
            + addRoadsToTour(tour: Tour, table: DijkstraTable, map: Map) : Tour
        }

        class MapService {
            - map : Map
            + loadMap(filePath: String) : void
        }

        class PlanningService {
            - requestService : RequestService
            - tourService : TourService
            - mapService : MapService
            + recomputeTourForCourier(courierId: long) : void
            + courierExists(courierId: long) : boolean
        }

        class IteratorSeq {
            - candidats : int[]
            - nbCandidats : int
            + IteratorSeq(nonVus: Collection<int>, sommetCrt: int, g: Graphe) : void
            + hasNext() : boolean
            + next() : int
            + remove() : void
        }

        class TemplateTSP {
            - meilleureSolution : int[]
            - g : Graphe
            - coutMeilleureSolution : int
            - tpsLimite : int
            - tpsDebut : long
            + chercheSolution(tpsLimite: int, g: Graphe) : void
            + getSolution(i: int) : int
            + getCoutSolution() : int
            + getCoutMeilleureSolution() : double
            + bound(sommetCourant: int, nonVus: Collection<int>) : int
            + iterator(sommetCrt: int, nonVus: Collection<int>, g: Graphe) : Iterator<int>
            + branchAndBound(sommetCrt: int, nonVus: Collection<int>, vus: Collection<int>, coutVus: int) : void
        }

        class TSP {
            + chercheSolution(tspLimite: int, g: Graphe): void
            + getSolution(i: int) : int
            + getCoutSolution() : int
        }

        class TSP1 {
            + bound(sommetCourant: int, nonVus: Collection<int>) : int
            + iterator(sommetCrt: int, nonVus: Collection<int>, g: Graphe) : Iterator<int>
        }
    }

    package "utils" {
        class DurationUtil {
            - COURIER_SPEED_KMH : double
            + computeDuration(roadSegment: RoadSegment) : double
        }
    }
}


package "Presentation" {
    class Main {
        + main(args: String[]): void
    }

    class RequestController {
        - requestService : RequestService
        - planningService : PlanningService
        + addRequest(warehouseId: Long, pickupIntersectionId: Long, pickupDurationInSeconds: long, deliveryIntersectionId: Long, deliveryDurationInSeconds: long, courierId: Long) : void
        + loadRequests(filepath: String, courrierId: long) : void
        + saveRequests(filepath: String) : void
        + deleteRequest(requestId: long, courierId: long) : void
        + getWarehouseAddress(): long
    }

    class TourController {
        - requestService : RequestService
        - tourService : TourService
        + saveTours(filepath: String) : void
        + loadTours(filepath: String) : void
        + addCourier(id: long, name: String, shiftDurationInSeconds: long) : void
        + removeCourier(courierId: long) : void
        + loadCouriers(filePath: string) : void
        + updateRequestOrder(requestBeforeId: long, requestAfterId: long, courierId: long) : void
        + showRequestDetails(instersectionId: long) : void
        + getTours() : Map<long, Tour>
        + getAvailableCouriers() : List<Courier>
    }

    class MapController {
        - mapService : MapService
        + getMap() : Map
    }
}

RequestController --> RequestService
RequestController --> PlanningService
TourController --> TourService
TourController --> RequestService

PlanningService --> RequestService
PlanningService --> TourService
PlanningService --> Map
PlanningService --> TSP1

TourService --> Tour
TourService --> Courier
RequestService --> PickupDelivery

PickupDelivery --> XMLWriters
Tour --> XMLWriters

PickupDelivery --> XMLParsers
Map --> XMLParsers
Tour --> XMLParsers

TemplateTSP <|.. TSP1
TemplateTSP --> Graphe
TSP <|-- TemplateTSP
Graphe <|-- GrapheComplet


Request --> Intersection : warehouseId
Request --> Intersection : pickupIntersectionId
Request --> Intersection : deliveryIntersectionId

PickupDelivery --> Courier : courierId

Tour --> Courier : courierId

TourStop --> Request : requestId

TourStop --> Intersection : intersectionId

RoadSegment --> Intersection : startId
RoadSegment --> Intersection : endId

Map "1" *-- "*" Intersection
Map "1" *-- "*" RoadSegment

PickupDelivery "1" o-- "*" Request
Tour "1" *-- "*" TourStop

Courier --> AvailabilityStatus

TourStop --> StopType

Tour --> RoadSegment

DijkstraService --> DijkstraTable
DijkstraTable --> CellInfo
DijkstraService --> GrapheComplet
DijkstraService --> Node
DijkstraService --> DurationUtil

@enduml