@startuml MCD

package "Persistence" {
    class XMLParsers {
        + parseMap(filePath: string) : Map
        + parseRequests(filePath: string, courierId: long, pickupDeliveryToFill: PickupDelivery) : void
        + parseCouriers(filePath: string) : ArrayList<Courier>
    }

    class XMLWriters {
        + writeTour(tour: Tour, filePath: string) : void
        + writeRequests(requests: PickupDelivery, filePath: string) : void
    }
}

package "Domain" {
    package "model" {
        class Intersection {
            - id : long
            - lat : double
            - lng : double
        }

        class RoadSegment {
            - name : String
            - length : double
            - startId : long
            - endId : long
        }

        class Map {
            - intersections : TreeMap<Long, Intersection>
            - adjacencyList : HashMap<Long, RoadSegment[]>
            + addIntersection(intersection: Intersection) : boolean
            + addRoadSegment(startIntersectionId: Long, roadSegment: RoadSegment) : boolean
            + getRoadSegment(startId: Long, endId: Long) : RoadSegment
            + getRoadSegmentByName(name: String) : ArrayList<RoadSegment>
        }

        class Tour {
            - courierId : long
            - stops : ArrayList<TourStop>
            - roadSegmentsTaken : ArrayList<RoadSegment>
            - totalDistance : double
            - startTime : LocalDateTime
            - totalDuration : Duration
            + Tour(courierId: long, startTime: LocalDateTime)
            + addStop(stop: TourStop) : void
            + addRoadSegment(roadSegment: RoadSegment) : void
            + updateTotalDistance(distance: double) : void
            + updateTotalDuration(duration: Duration) : void
            + getStopByIntersectionId(intersectionId: long) : TourStop
        }

        class TourStop {
            - type : StopType
            - requestId : long
            - intersectionId : long
            - arrivalTime : LocalDateTime
            - departureTime : LocalDateTime
        }

        enum StopType {
            - PICKUP
            - DELIVERY
            - INTERMEDIATE
            - WAREHOUSE
        }

        class Request {
            - id : long
            - warehouseId : long
            - pickupIntersectionId : long
            - pickupDuration : time.Duration
            - deliveryIntersectionId : long
            - deliveryDuration : time.Duration
            + generateId() : long
        }

        class Courier {
            - id : long
            - name : String
            - shiftDuration : Duration
            - availabilityStatus : AvailabilityStatus
            + Courier(id: long, name: String, shiftDuration: Duration)
            + isAvailable() : Boolean
            + isBusy() : Boolean
        }

        enum AvailabilityStatus {
            - AVAILABLE
            - BUSY
        }

        class PickupDelivery {
            - requests : ArrayList<Request>
            - departureTime : LocalDateTime
            - warehouseAddressId : long
            + PickupDelivery(other: PickupDelivery)
            + addRequest(request: Request) : void
            + removeRequest(requestId: long) : void
            + findRequestById(requestId: long) : Request
            + findRequestByIntersectionId(intersectionId: long) : Map.Entry<Request, StopType>
        }

        class Graphe {
            + getNbSommets() : int
            + getCout(i: int, j: int): int
            + estArc(i: int, j: int): boolean
        }

        class GrapheComplet {
            - sommets : long[]
            - nbSommets : int
            - cout : double[][]
            + GrapheComplet(nbSommets: int)
            + GrapheComplet(sommets: long[], nbSommets: int)
            + estArc(i: int, j: int) : boolean
        }

        package dijkstra {
            class Node {
                - vertex : Long
                - duration : double
                + Node(v: Long, d: double) : void
                + compareTo(other: Node) : int
            }

            class CellInfo {
                - duration : double
                - predecessor : long
                - visited : boolean
            }

            class DijkstraTable {
                - table : HashMap<Long, HashMap<Long, CellInfo>>
                + DijkstraTable()
                + put(row: long, col: long, duration: double, predecessor: long, visited: boolean) : void
                + put(row: long, col: long, cellInfo: CellInfo) : void
                + get(row: long, col: long) : CellInfo
                + contains(row: long, col: long) : boolean
                + remove(row: long, col: long) : void
            }
        }
    }

    package "service" {
        class DijkstraService {
            - map : Map
            - dijkstraTable : DijkstraTable
            + DijkstraService(map: Map)
            + computeShortestPath(stops: long[]) : GrapheComplet
            - dijkstra(start: int, g: GrapheComplet) : GrapheComplet
        }

        class RequestService {
            - pickupDeliveryPerCourier : TreeMap<Long, PickupDelivery>
            + addRequest(courierId: long, request: Request) : void
            + deleteRequest(courierId: long, requestId: long) : void
            + loadRequests(filepath: String, courierId: long) : boolean
            + saveRequests(filepath: String, courierId: long) : void
            + getAllWarehouseIds() : TreeMap<Long, Long>
            + getRequestById(requestId: long, courierId: long) : Request
            + setWarehouseAddress(warehouseId: long, courierId: long) : void
        }

        class TourService {
            - numCouriers : int
            - couriers : ArrayList<Courier>
            - tours : TreeMap<Long, Tour>
            - precedencesByCourier : TreeMap<Long, HashMap<String, Set<String>>>
            + addCourier(courier: Courier) : boolean
            + removeCourier(courierId: long) : boolean
            + loadCouriers(filepath: String) : void
            + convertGraphToTour(pickupDelivery: PickupDelivery, courierId: long, solution: Integer[], vertices: List<String>, costs: double[][]) : Tour
            + addRoadsToTour(tour: Tour, table: DijkstraTable, map: Map) : Tour
            + updateStopOrder(courierId: long, beforeStopIndex: Integer, afterStopIndex: Integer) : void
            + initPrecedences(courierId: long, requests: ArrayList<Request>) : void
            + generateTspPrecedences(requests: ArrayList<Request>, warehouseAddressId: long, courierId: long) : Entry<List<String>, HashMap<Integer, Set<Integer>>>
            + parseParams(requestId: long, intersectionID: long, type: char) : String
            + extractIntersectionIds(vertices: List<String>) : long[]
            + extractRequestId(vertix: String) : long
            + extractIntersectionId(vertix: String) : long
            + extractStopType(vertix: String) : StopType
            + getAvailableCouriers() : ArrayList<Courier>
            + exportTour(courierId: long, filePath: String) : void
        }


        class MapService {
            - map : Map
            + loadMap(filePath: String) : void
            + searchRoadSegmentsByName(name: string) : ArrayList<RoadSegment>
        }

        class PlanningService {
            - requestService : RequestService
            - tourService : TourService
            - mapService : MapService
            - dijkstraService : DijkstraService
            + PlanningService(requestService: RequestService, tourService: TourService, mapService: MapService)
            + recomputeTourForCourier(courierId: long) : void
            + courierExists(courierId: long) : boolean
            + updatePrecedences(courierId: long, newRequest: Request) : void
            + deletePrecedences(courierId: long, requestId: long) : void
            + courierInCharge(courierId: long) : Courier
            - printTSPSolution(tsp: TSP1, stops: long[], graph: Graphe, serviceTimes: double[]) : void
            - formatDuration(seconds: double) : String
        }

        class IteratorSeq {
            - iterator : Iterator<Integer>
            - candidats : List<Integer>
            + IteratorSeq(nonVus: Collection<Integer>, sommetCrt: int, g: Graphe)
            + hasNext() : boolean
            + next() : Integer
            + remove() : void
        }

        abstract class TemplateTSP {

            # g : Graphe
            - meilleureSolution : Integer[]
            - coutMeilleureSolution : double
            - tpsLimite : int
            - tpsDebut : long
            - precedences : Map<Integer, Set<Integer>>
            - serviceTimes : double[]
            - maxDuration : double
            - lastImprovementTime : long
            - NO_IMPROVEMENT_TIMEOUT : long
            - stopSearch : boolean
            + chercheSolution(tpsLimite: int, g: Graphe) : void
            + getCoutSolution() : double
            # bound(sommetCourant: Integer, nonVus: Collection<Integer>) : double
            # iterator(sommetCrt: Integer, nonVus: Collection<Integer>, g: Graphe) : Iterator<Integer>
            - branchAndBound(sommetCrt: int, nonVus: Collection<Integer>, vus: Collection<Integer>, coutVus: double) : void
            # nearestNeighborHeuristic() : double
        }

        class TSP {
            + chercheSolution(tspLimite: int, g: Graphe): void
            + getSolution(i: int) : Integer
            + getCoutSolution() : double
        }

        class TSP1 {
            + bound(sommetCourant: Integer, nonVus: Collection<Integer>) : double
            + iterator(sommetCrt: Integer, nonVus: Collection<Integer>, g: Graphe) : Iterator<Integer>
            - computeMSTCost(nonVus: Collection<Integer>) : double
        }
    }

    package "utils" {
        class DurationUtil {
            - COURIER_SPEED_KMH : double
            + computeDuration(roadSegment: RoadSegment) : double
        }
    }
}


package "Presentation" {

    class RequestController {
        - requestService: RequestService
        - planningService: PlanningService
        - tourService: TourService
        + RequestController(requestService: RequestService, planningService: PlanningService, tourService: TourService)
        + addRequest(warehouseId: Long, pickupIntersectionId: long, pickupDurationInSeconds: long, deliveryIntersectionId: long, deliveryDurationInSeconds: long, courierId: Long): ResponseEntity<?>
        + loadRequests(filepath: String, courierId: long): ResponseEntity<?>
        + saveRequests(filepath: String, courierId: long): ResponseEntity<?>
        + deleteRequest(requestId: long, courierId: long): ResponseEntity<?>
        + addWarehouse(warehouseId: long, courierId: long): void
        + getWarehouseAddress(): Map<Long, Long>
        - recomputeTourAndHandleExceptions(courierId: long): ResponseEntity<?>
    }

    class TourController {
        - planningService: PlanningService
        - tourService: TourService
        - requestService: RequestService
        + TourController(tourService: TourService, requestService: RequestService, planningService: PlanningService)
        + addCourier(id: long, name: String, shiftDurationInSeconds: long): boolean
        + removeCourier(courierId: long): boolean
        + loadCouriers(filepath: String): void
        + updateStopOrder(courierId: long, precStopIndex: Integer, followingStopIndex: Integer): ResponseEntity<?>
        + showRequestDetails(intersectionId: long, courierId: long): Map.Entry<Request, StopType>
        + getTours(): Map<Long, Tour>
        + getAvailableCouriers(): List<Courier>
        + saveTour(courierId: long, filepath: String): ResponseEntity<?>
    }

    class MapController {
        - mapService: MapService
        + MapController(mapService: MapService)
        + searchRoadSegments(name: string) : ArrayList<RoadSegment>
    }
}

RequestController --> RequestService
RequestController --> PlanningService
RequestController --> TourService
TourController --> TourService
TourController --> RequestService
TourController --> PlanningService
MapController --> MapService


PlanningService --> RequestService
PlanningService --> TourService
PlanningService --> MapService
PlanningService --> DijkstraService
PlanningService --> TSP1
PlanningService --> Graphe
PlanningService ..> GrapheComplet

TourService --> Tour
TourService --> Courier
TourService --> DijkstraTable
TourService --> PickupDelivery
TourService ..> XMLParsers
TourService ..> XMLWriters

RequestService --> PickupDelivery
RequestService --> Request
RequestService ..> XMLParsers
RequestService ..> XMLWriters

MapService ..> XMLParsers

PickupDelivery <-- XMLWriters
Tour <-- XMLWriters

PickupDelivery <-- XMLParsers
Map <-- XMLParsers
Courier <-- XMLParsers

IteratorSeq <-- TSP1
TemplateTSP <|.. TSP1
TemplateTSP --> Graphe
TSP <|-- TemplateTSP
Graphe <|-- GrapheComplet


Request --> Intersection : warehouseId
Request --> Intersection : pickupIntersectionId
Request --> Intersection : deliveryIntersectionId

PickupDelivery --> Courier : courierId

Tour --> Courier : courierId

TourStop --> Request : requestId

TourStop --> Intersection : intersectionId

RoadSegment "0..*" --> "1" Intersection : startId
RoadSegment "0..*" --> "1" Intersection : endId

Map "1" *-- "*" Intersection
Map "1" *-- "*" RoadSegment

PickupDelivery "1" o-- "*" Request
Tour "1" *-- "*" TourStop

Courier --> AvailabilityStatus

TourStop --> StopType

Tour --> RoadSegment

DijkstraService --> DijkstraTable
DijkstraService --> Map
DijkstraTable --> CellInfo
DijkstraService --> GrapheComplet
DijkstraService --> Node
DijkstraService --> DurationUtil

@enduml